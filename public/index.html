<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voxel Architect</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        :root { --bg: #e8ebee; --panel: rgba(255, 255, 255, 0.98); --text: #1a1a1a; --accent: #111; }
        body { margin: 0; overflow: hidden; background-color: var(--bg); font-family: 'Inter', sans-serif; color: var(--text); }
        #header { position: absolute; top: 40px; left: 40px; pointer-events: none; z-index: 10; }
        h1 { margin: 0; font-size: 28px; font-weight: 800; text-transform: uppercase; color: var(--accent); }
        p { margin: 4px 0 0; font-size: 14px; color: #666; font-weight: 500; }
        #ui-container { position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%); display: flex; align-items: center; gap: 12px; padding: 12px 16px; background: var(--panel); backdrop-filter: blur(20px); border-radius: 18px; box-shadow: 0 15px 50px rgba(0,0,0,0.1); z-index: 100; }
        input { border: none; background: rgba(0,0,0,0.05); padding: 14px 18px; border-radius: 10px; font-size: 16px; font-weight: 600; width: 220px; outline: none; }
        input:focus { background: #fff; box-shadow: 0 0 0 2px var(--accent); }
        button { border: none; cursor: pointer; padding: 14px 24px; border-radius: 10px; font-size: 14px; font-weight: 700; text-transform: uppercase; display: flex; align-items: center; gap: 8px; }
        #btn-gen { background-color: var(--accent); color: white; }
        #btn-break { background-color: transparent; color: var(--text); }
        .loader { width: 14px; height: 14px; border: 2px solid #fff; border-bottom-color: transparent; border-radius: 50%; display: none; animation: rotation 1s linear infinite; }
        @keyframes rotation { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #debug-console { position: absolute; top: 20px; right: 20px; width: 350px; background: rgba(0,0,0,0.9); color: #ff5555; font-family: monospace; font-size: 11px; padding: 20px; border-radius: 12px; z-index: 999; display: none; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div id="header"><h1>Voxel Architect</h1><p>Secure & Deployed</p></div>
    <div id="debug-console"><div id="debug-text"></div></div>
    <div id="ui-container">
        <input type="text" id="input-text" value="Block" placeholder="Type shape..." spellcheck="false">
        <button id="btn-gen"><span>Create</span><div class="loader" id="ai-loader"></div></button>
        <button id="btn-break">Shatter</button>
    </div>
    <script>
        const CONFIG={bg:0xe8ebee,floorY:-12,voxelSize:1,gap:0.02,maxParticles:8000,animSpeed:0.08};
        const P={RAW:0xcfd8dc};
        let scene,camera,renderer,controls,mesh,particles=[],dummy=new THREE.Object3D(),colorHelper=new THREE.Color();

        function init(){
            scene=new THREE.Scene(); scene.background=new THREE.Color(CONFIG.bg); scene.fog=new THREE.Fog(CONFIG.bg,30,100);
            camera=new THREE.PerspectiveCamera(40,window.innerWidth/window.innerHeight,0.1,1000); camera.position.set(30,25,30);
            renderer=new THREE.WebGLRenderer({antialias:true}); renderer.setSize(window.innerWidth,window.innerHeight);
            renderer.shadowMap.enabled=true; renderer.shadowMap.type=THREE.PCFSoftShadowMap; document.body.appendChild(renderer.domElement);
            controls=new THREE.OrbitControls(camera,renderer.domElement); controls.autoRotate=true; controls.autoRotateSpeed=0.5; controls.enableDamping=true;
            const h=new THREE.HemisphereLight(0xffffff,0x444444,0.65); const k=new THREE.DirectionalLight(0xfff0dd,1.2);
            k.position.set(20,40,20); k.castShadow=true; k.shadow.mapSize.width=2048; k.shadow.mapSize.height=2048; scene.add(h); scene.add(k);
            const pg=new THREE.PlaneGeometry(200,200); const pm=new THREE.ShadowMaterial({opacity:0.15});
            const p=new THREE.Mesh(pg,pm); p.rotation.x=-Math.PI/2; p.position.y=CONFIG.floorY; p.receiveShadow=true; scene.add(p);
            const g=new THREE.BoxGeometry(0.98,0.98,0.98); const m=new THREE.MeshStandardMaterial({roughness:0.4,metalness:0.1});
            mesh=new THREE.InstancedMesh(g,m,CONFIG.maxParticles); mesh.castShadow=true; mesh.receiveShadow=true; scene.add(mesh);
            
            const inp=document.getElementById('input-text');
            inp.addEventListener('focus',()=>controls.enabled=false); inp.addEventListener('blur',()=>controls.enabled=true);
            inp.addEventListener('keydown',e=>e.stopPropagation()); inp.addEventListener('keypress',e=>{if(e.key==='Enter')handleGenerate()});
            window.addEventListener('resize',()=>{camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight)});
            document.getElementById('btn-gen').onclick=handleGenerate; document.getElementById('btn-break').onclick=shatter;
            generateInternal('Block'); animate();
        }

        async function handleGenerate(){
            const txt=document.getElementById('input-text').value.trim(); if(!txt)return;
            document.getElementById('debug-console').style.display='none';
            const isPreset=['block','cube'].some(k=>txt.toLowerCase()===k);
            if(!isPreset) await generateWithAI(txt); else generateInternal(txt);
        }

        function logError(t,d){const e=document.getElementById('debug-console'),x=document.getElementById('debug-text');e.style.display='block';x.innerText=`${t}\n${d}`;}
        function generateInternal(t){let trg=[]; const add=(x,y,z,c)=>trg.push({x,y,z,c}); for(let x=-6;x<6;x++)for(let y=0;y<12;y++)for(let z=-6;z<6;z++)add(x,y,z,P.RAW); processTargets(trg);}

        // --- SECURE SERVER CALL ---
        async function generateWithAI(prompt) {
            const l=document.getElementById('ai-loader'),b=document.querySelector('#btn-gen span');
            l.style.display='block'; b.style.display='none';
            
            try {
                // CALL THE BACKEND INSTEAD OF GOOGLE DIRECTLY
                const response = await fetch('/api/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt })
                });

                const data = await response.json();
                if(data.error) throw new Error(data.error);
                
                if(Array.isArray(data)) {
                    const targets = data.map(v => ({
                        x: v.x||0, y: v.y||0, z: v.z||0,
                        c: parseInt((v.c||"#888888").replace('#', '0x'), 16)
                    }));
                    processTargets(targets);
                } else throw new Error("Invalid Data from Server");

            } catch(e) {
                logError("Server Error", e.message);
                generateInternal("block");
            } finally {
                l.style.display='none'; b.style.display='block';
            }
        }

        function processTargets(t){
            let mx=0,my=0,mz=0; t.forEach(o=>{mx+=o.x;my+=o.y;mz+=o.z}); const cx=mx/t.length,cy=my/t.length,cz=mz/t.length;
            t.forEach(o=>{o.wx=(o.x-cx)*CONFIG.voxelSize;o.wy=(o.y-cy)*CONFIG.voxelSize+5;o.wz=(o.z-cz)*CONFIG.voxelSize});
            while(particles.length<t.length) particles.push({x:(Math.random()-.5)*20,y:CONFIG.floorY+.5,z:(Math.random()-.5)*20,rx:Math.random()*Math.PI,c:0xcfd8dc,state:'FLOOR',vx:0,vy:0,vz:0});
            particles.forEach((p,i)=>{if(i<t.length){p.target=t[i];p.state='FLYING';p.delay=(t[i].y*3)+Math.random()*10}else p.state='FLOOR'});
            controls.autoRotate=true;
        }
        function shatter(){controls.autoRotate=false;particles.forEach(p=>{if(p.state==='ASSEMBLED'||p.state==='FLYING'){p.state='FALLING';p.vx=(Math.random()-.5);p.vy=Math.random();p.vz=(Math.random()-.5);p.vrx=(Math.random()-.5)*.2}})}
        function animate(){requestAnimationFrame(animate);controls.update();mesh.count=Math.min(particles.length,CONFIG.maxParticles);
            for(let i=0;i<mesh.count;i++){const p=particles[i];
                if(p.state==='FLYING'){if(p.delay>0){p.delay--;if(p.y<CONFIG.floorY+2)p.rx+=.1}else{const dx=p.target.wx-p.x,dy=p.target.wy-p.y,dz=p.target.wz-p.z;p.x+=dx*CONFIG.animSpeed;p.y+=dy*CONFIG.animSpeed;p.z+=dz*CONFIG.animSpeed;p.rx*=0.8;if(Math.abs(dx)+Math.abs(dy)+Math.abs(dz)<.1){p.state='ASSEMBLED';p.x=p.target.wx;p.y=p.target.wy;p.z=p.target.wz;p.c=p.target.c;p.rx=0}else p.c=p.target.c}}
                else if(p.state==='ASSEMBLED'){p.x=p.target.wx;p.y=p.target.wy;p.z=p.target.wz}
                else if(p.state==='FALLING'){p.vy+=-.03;p.x+=p.vx;p.y+=p.vy;p.z+=p.vz;p.rx+=p.vrx;if(p.y<CONFIG.floorY+.5){p.y=CONFIG.floorY+.5;p.vy*=-.5;p.vx*=.95;p.vz*=.95;if(Math.abs(p.vy)<.05)p.state='FLOOR'}}
                else if(p.state==='FLOOR')p.y=CONFIG.floorY+.5;
                dummy.position.set(p.x,p.y,p.z);dummy.rotation.set(p.rx,p.rx,p.rx);dummy.updateMatrix();mesh.setMatrixAt(i,dummy.matrix);mesh.setColorAt(i,colorHelper.setHex(p.c));
            }mesh.instanceMatrix.needsUpdate=true;mesh.instanceColor.needsUpdate=true;renderer.render(scene,camera);
        }
        init();
    </script>
</body>
</html>