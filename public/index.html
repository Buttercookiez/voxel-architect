<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voxel Architect</title>
    <style>
        :root { --bg: #e8ebee; --panel: rgba(255, 255, 255, 0.98); --text: #1a1a1a; --accent: #111; }
        body { margin: 0; overflow: hidden; background-color: var(--bg); font-family: sans-serif; }
        #ui-container { position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; padding: 10px; background: var(--panel); border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.1); }
        input { padding: 10px; border-radius: 8px; border: none; background: #f0f0f0; outline:none; width: 200px; }
        button { padding: 10px 20px; border-radius: 8px; border: none; background: #111; color: white; cursor: pointer; }
        #debug { position: absolute; top: 10px; right: 10px; font-family: monospace; font-size: 10px; color: red; white-space: pre; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div id="debug"></div>
    <div id="ui-container">
        <input type="text" id="input-text" value="Car" placeholder="Type shape...">
        <button id="btn-gen">Create</button>
    </div>
    <script>
        let scene, camera, renderer, controls, mesh, particles = [];
        
        function init() {
            scene = new THREE.Scene(); scene.background = new THREE.Color(0xe8ebee);
            camera = new THREE.PerspectiveCamera(40, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(30, 25, 30);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.autoRotate = true;

            const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8); scene.add(hemi);
            const dir = new THREE.DirectionalLight(0xffffff, 1); dir.position.set(10,20,10); dir.castShadow=true; scene.add(dir);
            
            const g = new THREE.BoxGeometry(0.95, 0.95, 0.95);
            const m = new THREE.MeshStandardMaterial({ roughness: 0.5, metalness: 0.1 });
            mesh = new THREE.InstancedMesh(g, m, 5000);
            mesh.castShadow = true; mesh.receiveShadow = true;
            scene.add(mesh);

            const pg = new THREE.PlaneGeometry(100,100);
            const pm = new THREE.ShadowMaterial({opacity:0.2});
            const p = new THREE.Mesh(pg,pm); p.rotation.x=-Math.PI/2; p.position.y=-10; p.receiveShadow=true; scene.add(p);

            document.getElementById('btn-gen').onclick = () => generate(document.getElementById('input-text').value);
            
            animate();
        }

        async function generate(prompt) {
            document.getElementById('debug').innerText = "Generating...";
            try {
                // CALL THE SERVERLESS FUNCTION
                const res = await fetch('/api/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt })
                });
                
                const data = await res.json();
                
                if (data.error) {
                    document.getElementById('debug').innerText = "Server Error:\n" + data.error;
                    return;
                }

                // Process Voxels
                process(data);
                document.getElementById('debug').innerText = "";
            } catch (e) {
                document.getElementById('debug').innerText = "Network Error:\n" + e.message;
            }
        }

        function process(data) {
            let mx=0, my=0, mz=0;
            data.forEach(d => { mx+=d.x; my+=d.y; mz+=d.z; });
            const cx=mx/data.length, cy=my/data.length, cz=mz/data.length;

            particles = data.map(d => ({
                x: d.x-cx, y: d.y-cy+5, z: d.z-cz,
                c: parseInt(d.c.replace('#', '0x'), 16)
            }));
        }

        const dummy = new THREE.Object3D();
        const col = new THREE.Color();

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            
            mesh.count = particles.length;
            for(let i=0; i<particles.length; i++) {
                const p = particles[i];
                dummy.position.set(p.x, p.y, p.z);
                dummy.updateMatrix();
                mesh.setMatrixAt(i, dummy.matrix);
                mesh.setColorAt(i, col.setHex(p.c));
            }
            mesh.instanceMatrix.needsUpdate = true;
            mesh.instanceColor.needsUpdate = true;
            
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>