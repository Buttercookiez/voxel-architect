<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voxel Architect | Elegant Mode</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">

    <style>
        :root { --bg: #e0e5ec; --panel: rgba(255, 255, 255, 0.98); --text: #1a1a1a; --accent: #111; }
        body { margin: 0; overflow: hidden; background-color: var(--bg); font-family: 'Inter', sans-serif; color: var(--text); }
        
        #header { position: absolute; top: 40px; left: 40px; pointer-events: none; z-index: 10; }
        h1 { margin: 0; font-size: 32px; font-weight: 800; text-transform: uppercase; color: var(--accent); letter-spacing: -1.5px; }
        p { margin: 4px 0 0; font-size: 14px; color: #555; font-weight: 500; }

        #ui-container {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            display: flex; align-items: center; gap: 12px; padding: 12px 16px;
            background: var(--panel); backdrop-filter: blur(20px); border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.1); z-index: 100; border: 1px solid rgba(255,255,255,0.5);
        }
        
        input {
            border: none; background: rgba(0,0,0,0.05); padding: 14px 18px; border-radius: 10px;
            font-size: 16px; font-weight: 600; width: 250px; outline: none; transition: 0.2s;
        }
        input:focus { background: #fff; box-shadow: 0 0 0 2px var(--accent); }

        button {
            border: none; cursor: pointer; padding: 14px 24px; border-radius: 10px;
            font-size: 14px; font-weight: 700; text-transform: uppercase; display: flex; align-items: center; gap: 8px;
            transition: transform 0.1s;
        }
        button:active { transform: scale(0.95); }
        #btn-gen { background-color: var(--accent); color: white; }
        #btn-break { background-color: transparent; color: var(--text); border: 1px solid transparent; }
        
        .loader {
            width: 16px; height: 16px; border: 2px solid #fff; border-bottom-color: transparent;
            border-radius: 50%; display: none; animation: rotation 0.8s linear infinite;
        }
        @keyframes rotation { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        #status-toast {
            position: absolute; top: 30px; right: 30px; 
            background: #111; color: #fff; font-family: monospace; font-size: 13px;
            padding: 16px 20px; border-radius: 12px; z-index: 200; display: none;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2); border-left: 4px solid #00ff00;
            max-width: 400px; line-height: 1.4;
        }
        .error-toast { border-left-color: #ff4444 !important; }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

    <div id="header">
        <h1>Voxel Architect</h1>
        <p>Gemini 2.5 | Slow Motion Build</p>
    </div>

    <div id="status-toast">Ready</div>

    <div id="ui-container">
        <input type="text" id="input-text" value="Fox" placeholder="Type object..." spellcheck="false">
        <button id="btn-gen">
            <span>Create</span>
            <div class="loader" id="ai-loader"></div>
        </button>
        <button id="btn-break">Shatter</button>
    </div>

    <script>
        const API_KEY = "AIzaSyD5Q3y40BPiwtSUzBTRoU2n2CgIiqWrYpE";
        const MODEL = "gemini-2.5-flash";

        // --- SLOW ANIMATION CONFIG ---
        // animSpeed lowered from 0.2 to 0.03 for very slow floating
        const CONFIG = { bg: 0xe0e5ec, floorY: -12, voxelSize: 1, gap: 0.02, maxParticles: 12000, animSpeed: 0.03 };
        const P = { RAW: 0xcfd8dc };

        let scene, camera, renderer, controls, mesh, particles = [], dummy = new THREE.Object3D(), colorHelper = new THREE.Color();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.bg);
            scene.fog = new THREE.Fog(CONFIG.bg, 30, 120);
            
            camera = new THREE.PerspectiveCamera(40, window.innerWidth/window.innerHeight, 0.1, 2000);
            camera.position.set(35, 25, 35); // Adjusted camera for better angle

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            document.body.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.8; // Slower idle spin
            controls.enableDamping = true;

            // Cinematic Lighting
            const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            const keyLight = new THREE.DirectionalLight(0xfff0dd, 1.4);
            keyLight.position.set(20, 50, 20);
            keyLight.castShadow = true;
            keyLight.shadow.mapSize.width = 4096; 
            keyLight.shadow.mapSize.height = 4096;
            scene.add(hemi); scene.add(keyLight);
            
            // Shadow Floor
            const planeGeo = new THREE.PlaneGeometry(300, 300);
            const planeMat = new THREE.ShadowMaterial({ opacity: 0.15 });
            const plane = new THREE.Mesh(planeGeo, planeMat);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = CONFIG.floorY;
            plane.receiveShadow = true;
            scene.add(plane);

            const g = new THREE.BoxGeometry(0.98, 0.98, 0.98);
            const m = new THREE.MeshStandardMaterial({ roughness: 0.4, metalness: 0.1 });
            mesh = new THREE.InstancedMesh(g, m, CONFIG.maxParticles);
            mesh.castShadow = true; mesh.receiveShadow = true;
            scene.add(mesh);

            const inputField = document.getElementById('input-text');
            inputField.addEventListener('focus', () => controls.enabled = false);
            inputField.addEventListener('blur', () => controls.enabled = true);
            inputField.addEventListener('keydown', (e) => e.stopPropagation());
            inputField.addEventListener('keypress', (e) => { if(e.key === 'Enter') handleGenerate(); });

            window.addEventListener('resize', onResize);
            document.getElementById('btn-gen').onclick = handleGenerate;
            document.getElementById('btn-break').onclick = shatter;

            generateInternal('Block');
            animate();
        }

        async function handleGenerate() {
            const txt = document.getElementById('input-text').value.trim();
            if(!txt) return;
            const isPreset = ['block','cube','box'].some(k => txt.toLowerCase() === k);
            if (!isPreset) await generateWithAI(txt); else generateInternal();
        }

        function showToast(msg, isError = false) {
            const el = document.getElementById('status-toast');
            el.innerText = msg;
            el.className = isError ? 'error-toast' : '';
            el.style.display = 'block';
            setTimeout(() => el.style.display = 'none', isError ? 6000 : 3000);
        }

        function generateInternal() {
            let targets = [];
            const add = (x,y,z,c) => targets.push({x,y,z,c});
            for(let x=-5; x<5; x++) for(let y=0; y<10; y++) for(let z=-5; z<5; z++) add(x,y,z, P.RAW);
            processTargets(targets);
        }

        // --- AI REQUEST ---
        async function generateWithAI(prompt) {
            const loader = document.getElementById('ai-loader');
            const btnSpan = document.querySelector('#btn-gen span');
            loader.style.display = 'block';
            btnSpan.style.display = 'none';

            try {
                const url = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL}:generateContent?key=${API_KEY}`;
                
                const systemPrompt = `
                    You are a 3D Voxel Artist.
                    User wants: "${prompt}".
                    
                    Instructions:
                    1. Return raw JSON Array ONLY: [{"x":0,"y":0,"z":0,"c":"#FF0000"}].
                    2. No text labels. Build the OBJECT.
                    3. DO NOT SWAP AXES. Y is Up.
                    4. Use varied, vibrant colors.
                    5. Max dimensions 16x16x16.
                `;

                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: systemPrompt }] }],
                        generationConfig: { 
                            temperature: 0.3, 
                            maxOutputTokens: 30000 // High limit for complex models
                        },
                        safetySettings: [{ category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" }]
                    })
                });

                if (!response.ok) {
                    const err = await response.json();
                    throw new Error(err.error?.message || "API Error");
                }

                const data = await response.json();
                if (!data.candidates || !data.candidates[0].content) throw new Error("Empty AI response.");

                let text = data.candidates[0].content.parts[0].text;
                text = text.replace(/```json/g, '').replace(/```/g, '').trim();
                
                const first = text.indexOf('[');
                const last = text.lastIndexOf(']');
                
                if (first === -1 || last === -1) throw new Error("AI data corrupted.");
                text = text.substring(first, last+1);

                let voxelData = JSON.parse(text);
                
                if (Array.isArray(voxelData) && voxelData.length > 0) {
                    const targets = voxelData.map(v => ({
                        // --- FIX FOR SIDEWAYS: ENSURE Y IS UP ---
                        // Gemini often uses Y as vertical correctly, but if it flips, swap here.
                        // Current standard: Three.js Y=Up.
                        x: parseInt(v.x)||0, 
                        y: parseInt(v.y)||0,  // Y is height
                        z: parseInt(v.z)||0,  // Z is depth
                        c: parseInt((v.c||"#888888").replace('#', '0x'), 16)
                    }));
                    showToast(`Generated: ${prompt}`);
                    processTargets(targets);
                } else {
                    throw new Error("Empty data array.");
                }

            } catch (e) {
                console.error(e);
                showToast(`Error: ${e.message}`, true);
                generateInternal();
            } finally {
                loader.style.display = 'none';
                btnSpan.style.display = 'block';
            }
        }

        function processTargets(targets) {
            // Center object
            let mx=0, my=0, mz=0;
            targets.forEach(t => { mx+=t.x; my+=t.y; mz+=t.z; });
            const cx = mx/targets.length, cy = my/targets.length, cz = mz/targets.length;

            // Map targets to World Coordinates
            targets.forEach(t => {
                t.wx = (t.x - cx) * CONFIG.voxelSize;
                t.wy = (t.y - cy) * CONFIG.voxelSize + 5; // +5 height
                t.wz = (t.z - cz) * CONFIG.voxelSize;
            });

            // Ensure we have particles
            if(particles.length === 0) {
                for(let i=0; i<CONFIG.maxParticles; i++) {
                    particles.push({
                        x: (Math.random()-0.5)*30, y: CONFIG.floorY+0.5, z: (Math.random()-0.5)*30,
                        rx: 0, c: 0xcfd8dc, state: 'FLOOR', vx:0, vy:0, vz:0
                    });
                }
            }

            // Assign new targets
            particles.forEach((p, i) => {
                if(i < targets.length) {
                    p.target = targets[i];
                    p.state = 'FLYING';
                    
                    // SLOW SEQUENCE: Height based delay
                    // Multiply by 10 makes it take much longer to start rising
                    p.delay = (targets[i].y * 15) + Math.random()*20; 
                } else {
                    p.state = 'FLOOR';
                }
            });
            controls.autoRotate = true;
        }

        function shatter() {
            controls.autoRotate = false;
            particles.forEach(p => {
                if(p.state === 'ASSEMBLED' || p.state === 'FLYING') {
                    p.state = 'FALLING';
                    p.vx=(Math.random()-0.5)*1.0;
                    p.vy=Math.random()*1.2; 
                    p.vz=(Math.random()-0.5)*1.0;
                    p.vrx=(Math.random()-0.5)*0.5;
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            
            mesh.count = Math.min(particles.length, CONFIG.maxParticles);
            
            // Physics settings
            const G = -0.03; // Slower gravity
            const F = 0.95; 

            for(let i=0; i<mesh.count; i++) {
                const p = particles[i];
                
                if(p.state==='FLYING') {
                    if(p.delay > 0) { 
                        p.delay--; 
                        // Slight floor vibration while waiting
                        if(p.y < CONFIG.floorY+2) { p.rx += 0.05; }
                    } 
                    else {
                        // Interpolation to target (Magnetic Fly)
                        const dx = p.target.wx - p.x;
                        const dy = p.target.wy - p.y;
                        const dz = p.target.wz - p.z;
                        
                        // Move towards target slowly (Lerp)
                        p.x += dx * CONFIG.animSpeed;
                        p.y += dy * CONFIG.animSpeed;
                        p.z += dz * CONFIG.animSpeed;
                        
                        p.rx *= 0.9; // Dampen rotation

                        // Check if arrived
                        const dist = Math.abs(dx)+Math.abs(dy)+Math.abs(dz);
                        if(dist < 0.1) {
                            p.state='ASSEMBLED'; 
                            // Snap perfectly
                            p.x=p.target.wx; p.y=p.target.wy; p.z=p.target.wz; 
                            p.c=p.target.c; p.rx=0;
                        } else {
                            // Change color to target mid-flight for effect
                            p.c=p.target.c; 
                        }
                    }
                } 
                else if(p.state==='ASSEMBLED') {
                    // Lock position
                    p.x=p.target.wx; p.y=p.target.wy; p.z=p.target.wz;
                } 
                else if(p.state==='FALLING') {
                    p.vy += G; 
                    p.x += p.vx; 
                    p.y += p.vy; 
                    p.z += p.vz; 
                    p.rx += p.vrx;
                    
                    // Bounce off floor
                    if(p.y < CONFIG.floorY+0.5) { 
                        p.y = CONFIG.floorY+0.5; 
                        p.vy *= -0.6; 
                        p.vx *= F; 
                        p.vz *= F; 
                        if(Math.abs(p.vy) < 0.1) p.state='FLOOR'; 
                    }
                } 
                else if(p.state==='FLOOR') {
                    p.y = CONFIG.floorY+0.5;
                }

                dummy.position.set(p.x, p.y, p.z);
                dummy.rotation.set(p.rx, p.rx, p.rx);
                dummy.updateMatrix();
                mesh.setMatrixAt(i, dummy.matrix);
                mesh.setColorAt(i, colorHelper.setHex(p.c));
            }
            
            mesh.instanceMatrix.needsUpdate = true;
            mesh.instanceColor.needsUpdate = true;
            renderer.render(scene, camera);
        }

        function onResize() {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>