<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voxel Architect | Auto-Fixing</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">

    <style>
        :root { --bg: #e8ebee; --panel: rgba(255, 255, 255, 0.98); --text: #1a1a1a; --accent: #111; }
        body { margin: 0; overflow: hidden; background-color: var(--bg); font-family: 'Inter', sans-serif; color: var(--text); }
        
        #header { position: absolute; top: 40px; left: 40px; pointer-events: none; z-index: 10; }
        h1 { margin: 0; font-size: 28px; font-weight: 800; text-transform: uppercase; color: var(--accent); }
        p { margin: 4px 0 0; font-size: 14px; color: #666; font-weight: 500; }

        #ui-container {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            display: flex; align-items: center; gap: 12px; padding: 12px 16px;
            background: var(--panel); backdrop-filter: blur(20px); border-radius: 18px;
            box-shadow: 0 15px 50px rgba(0,0,0,0.1); z-index: 100;
        }
        
        input {
            border: none; background: rgba(0,0,0,0.05); padding: 14px 18px; border-radius: 10px;
            font-size: 16px; font-weight: 600; width: 220px; outline: none;
        }
        input:focus { background: #fff; box-shadow: 0 0 0 2px var(--accent); }

        button {
            border: none; cursor: pointer; padding: 14px 24px; border-radius: 10px;
            font-size: 14px; font-weight: 700; text-transform: uppercase; display: flex; align-items: center; gap: 8px;
        }
        #btn-gen { background-color: var(--accent); color: white; }
        #btn-gen:hover { transform: scale(1.05); }
        #btn-break { background-color: transparent; color: var(--text); border: 1px solid transparent; }
        
        .loader {
            width: 14px; height: 14px; border: 2px solid #fff; border-bottom-color: transparent;
            border-radius: 50%; display: none; animation: rotation 0.5s linear infinite;
        }
        @keyframes rotation { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* NOTIFICATIONS */
        #status-toast {
            position: absolute; top: 20px; right: 20px; 
            background: #111; color: #fff; font-family: monospace; font-size: 12px;
            padding: 15px; border-radius: 8px; z-index: 200; display: none;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3); max-width: 350px; border-left: 4px solid #44ff44;
            white-space: pre-wrap; word-wrap: break-word;
        }
        .error-toast { border-left-color: #ff4444 !important; background: #220000 !important; }
        .retry-toast { border-left-color: #ffaa00 !important; }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

    <div id="header">
        <h1>Voxel Architect</h1>
        <p>Auto-Correcting AI</p>
    </div>

    <div id="status-toast">System Ready</div>

    <div id="ui-container">
        <input type="text" id="input-text" value="Orange Fox" placeholder="Type object (e.g. Burger)" spellcheck="false">
        <button id="btn-gen">
            <span>Create</span>
            <div class="loader" id="ai-loader"></div>
        </button>
        <button id="btn-break">Shatter</button>
    </div>

    <script>
        // YOUR API KEY (Hardcoded for you)
        const API_KEY = "AIzaSyD5Q3y40BPiwtSUzBTRoU2n2CgIiqWrYpE";

        // --- CONFIG ---
        const CONFIG = { bg: 0xe8ebee, floorY: -12, voxelSize: 1, gap: 0.02, maxParticles: 8000, animSpeed: 0.2 };
        const P = { RAW: 0xcfd8dc };

        let scene, camera, renderer, controls, mesh, particles = [], dummy = new THREE.Object3D(), colorHelper = new THREE.Color();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.bg);
            scene.fog = new THREE.Fog(CONFIG.bg, 30, 100);
            
            camera = new THREE.PerspectiveCamera(40, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(30, 25, 30);

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            document.body.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.autoRotate = true;
            controls.autoRotateSpeed = 2.0;
            controls.enableDamping = true;

            const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.65);
            const keyLight = new THREE.DirectionalLight(0xfff0dd, 1.2);
            keyLight.position.set(20, 40, 20);
            keyLight.castShadow = true;
            keyLight.shadow.mapSize.width = 2048; keyLight.shadow.mapSize.height = 2048;
            scene.add(hemi); scene.add(keyLight);
            
            const planeGeo = new THREE.PlaneGeometry(200, 200);
            const planeMat = new THREE.ShadowMaterial({ opacity: 0.15 });
            const plane = new THREE.Mesh(planeGeo, planeMat);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = CONFIG.floorY;
            plane.receiveShadow = true;
            scene.add(plane);

            const g = new THREE.BoxGeometry(0.98, 0.98, 0.98);
            const m = new THREE.MeshStandardMaterial({ roughness: 0.4, metalness: 0.1 });
            mesh = new THREE.InstancedMesh(g, m, CONFIG.maxParticles);
            mesh.castShadow = true; mesh.receiveShadow = true;
            scene.add(mesh);

            const inputField = document.getElementById('input-text');
            inputField.addEventListener('focus', () => controls.enabled = false);
            inputField.addEventListener('blur', () => controls.enabled = true);
            inputField.addEventListener('keydown', (e) => e.stopPropagation());
            inputField.addEventListener('keypress', (e) => { if(e.key === 'Enter') handleGenerate(); });

            window.addEventListener('resize', onResize);
            document.getElementById('btn-gen').onclick = handleGenerate;
            document.getElementById('btn-break').onclick = shatter;

            generateInternal('Block');
            animate();
        }

        async function handleGenerate() {
            const txt = document.getElementById('input-text').value.trim();
            if(!txt) return;
            // Quick checks for hardcoded
            const isPreset = ['block','cube','box'].some(k => txt.toLowerCase() === k);
            if (!isPreset) await generateWithAI(txt); else generateInternal(txt);
        }

        function showToast(msg, type = 'success') {
            const el = document.getElementById('status-toast');
            el.innerText = msg;
            el.className = type === 'error' ? 'error-toast' : (type === 'retry' ? 'retry-toast' : '');
            el.style.display = 'block';
            if(type === 'success') setTimeout(() => el.style.display = 'none', 4000);
        }

        function generateInternal(type) {
            let targets = [];
            const add = (x,y,z,c) => targets.push({x,y,z,c});
            for(let x=-6; x<6; x++) for(let y=0; y<12; y++) for(let z=-6; z<6; z++) add(x,y,z, P.RAW);
            processTargets(targets);
        }

        // --- AUTO-FIXING AI REQUEST ---
        async function generateWithAI(prompt) {
            const loader = document.getElementById('ai-loader');
            const btnSpan = document.querySelector('#btn-gen span');
            loader.style.display = 'block';
            btnSpan.style.display = 'none';

            // LIST OF ALL POSSIBLE MODEL NAMES (Prioritizing stability)
            const MODEL_CANDIDATES = [
                "gemini-1.5-flash-latest", // Attempt Newest
                "gemini-1.5-flash-002",    // Attempt Specific V2
                "gemini-1.5-flash-001",    // Attempt Specific V1
                "gemini-1.5-flash",        // Attempt Generic Alias
                "gemini-1.5-pro-latest",
                "gemini-pro"               // Final Legacy fallback
            ];

            let success = false;
            let lastError = "";

            for(let i=0; i<MODEL_CANDIDATES.length; i++) {
                const currentModel = MODEL_CANDIDATES[i];
                
                try {
                    // Don't spam toast, just log console
                    console.log(`Attempting connection via: ${currentModel}`);
                    
                    const url = `https://generativelanguage.googleapis.com/v1beta/models/${currentModel}:generateContent?key=${API_KEY}`;
                    
                    const systemPrompt = `
                        You are a 3D Voxel Artist.
                        User wants: "${prompt}".
                        
                        CRITICAL INSTRUCTION:
                        DO NOT create text or letters.
                        Create the ACTUAL PHYSICAL OBJECT/CREATURE.
                        
                        Format: ONLY a raw JSON Array of voxels.
                        Schema: [{"x": int, "y": int, "z": int, "c": "hexString"}]
                        Constraints: Approx 12x12x12 blocks. High detail.
                    `;

                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: systemPrompt }] }],
                            generationConfig: { 
                                temperature: 0.4, 
                                maxOutputTokens: 2000 
                            },
                            safetySettings: [
                                { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
                                { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
                                { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
                                { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" }
                            ]
                        })
                    });

                    // Handle Errors
                    if (!response.ok) {
                        const status = response.status;
                        if (status === 404) {
                            // Model version mismatch, throw specific error to continue loop
                            throw new Error("VERSION_MISMATCH"); 
                        } else if (status === 429) {
                            throw new Error("QUOTA_EXCEEDED");
                        }
                        const errData = await response.json();
                        throw new Error(errData.error?.message || "API Error");
                    }

                    const data = await response.json();
                    if (!data.candidates || !data.candidates[0].content) throw new Error("EMPTY_RESPONSE");

                    // Parse Response
                    let text = data.candidates[0].content.parts[0].text;
                    text = text.replace(/```json/g, '').replace(/```/g, '').trim();
                    
                    // Robust Extractor
                    const first = text.indexOf('[');
                    const last = text.lastIndexOf(']');
                    if(first === -1 || last === -1) throw new Error("INVALID_JSON_FORMAT");
                    text = text.substring(first, last+1);

                    const voxelData = JSON.parse(text);
                    
                    if(Array.isArray(voxelData) && voxelData.length > 0) {
                        // Data Validation
                        const targets = voxelData.map(v => ({
                            x: v.x||0, y: v.y||0, z: v.z||0,
                            c: parseInt((v.c||"#888888").replace('#', '0x'), 16)
                        }));
                        
                        showToast(`Built with: ${currentModel}`, 'success');
                        processTargets(targets);
                        success = true;
                        break; // EXIT LOOP - WE ARE DONE
                    } else {
                        throw new Error("EMPTY_DATA_ARRAY");
                    }

                } catch (e) {
                    lastError = e.message;
                    // If version mismatch, continue loop silentlhy
                    if(e.message === "VERSION_MISMATCH") continue; 
                    
                    console.warn(`Failed on ${currentModel}: ${e.message}`);
                    if(e.message === "QUOTA_EXCEEDED") break; // Don't retry if we have no quota
                }
            }

            if (!success) {
                showToast(`Failed: ${lastError}`, 'error');
                // Immediate Fallback so screen isn't black
                generateInternal("block"); 
            }
            
            loader.style.display = 'none';
            btnSpan.style.display = 'block';
        }

        function processTargets(targets) {
            // Calculate Center
            let mx=0, my=0, mz=0;
            targets.forEach(t => { mx+=t.x; my+=t.y; mz+=t.z; });
            const cx = mx/targets.length, cy = my/targets.length, cz = mz/targets.length;

            targets.forEach(t => {
                t.wx = (t.x - cx) * CONFIG.voxelSize;
                t.wy = (t.y - cy) * CONFIG.voxelSize + 5; // Lift slightly above floor
                t.wz = (t.z - cz) * CONFIG.voxelSize;
            });

            // Pool Management
            if(particles.length === 0) {
                for(let i=0; i<CONFIG.maxParticles; i++) {
                    particles.push({
                        x: (Math.random()-0.5)*20, y: CONFIG.floorY+0.5, z: (Math.random()-0.5)*20,
                        rx: Math.random()*Math.PI, c: 0xcfd8dc, state: 'FLOOR', vx:0, vy:0, vz:0
                    });
                }
            }

            // Assign
            particles.forEach((p, i) => {
                if(i < targets.length) {
                    p.target = targets[i];
                    p.state = 'FLYING';
                    p.delay = (targets[i].y * 1) + Math.random()*5; 
                } else {
                    p.state = 'FLOOR';
                }
            });
            controls.autoRotate = true;
        }

        function shatter() {
            controls.autoRotate = false;
            particles.forEach(p => {
                if(p.state === 'ASSEMBLED' || p.state === 'FLYING') {
                    p.state = 'FALLING';
                    p.vx=(Math.random()-0.5)*1.5;
                    p.vy=Math.random()*1.5; 
                    p.vz=(Math.random()-0.5)*1.5;
                    p.vrx=(Math.random()-0.5)*0.5;
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            const count = Math.min(particles.length, CONFIG.maxParticles);
            mesh.count = count;
            const G=-0.05, F=0.95; 

            for(let i=0; i<count; i++) {
                const p = particles[i];
                if(p.state==='FLYING') {
                    if(p.delay>0) {
                        p.delay--;
                        if(p.y < CONFIG.floorY+2) p.rx += 0.2;
                    } else {
                        const dx=p.target.wx-p.x, dy=p.target.wy-p.y, dz=p.target.wz-p.z;
                        p.x+=dx*CONFIG.animSpeed; p.y+=dy*CONFIG.animSpeed; p.z+=dz*CONFIG.animSpeed;
                        p.rx*=0.7;
                        if(Math.abs(dx)+Math.abs(dy)+Math.abs(dz)<0.1) {
                            p.state='ASSEMBLED'; p.x=p.target.wx; p.y=p.target.wy; p.z=p.target.wz; p.c=p.target.c; p.rx=0;
                        } else p.c=p.target.c;
                    }
                } else if(p.state==='ASSEMBLED') {
                    p.x=p.target.wx; p.y=p.target.wy; p.z=p.target.wz;
                } else if(p.state==='FALLING') {
                    p.vy+=G; p.x+=p.vx; p.y+=p.vy; p.z+=p.vz; p.rx+=p.vrx;
                    if(p.y<CONFIG.floorY+0.5) { p.y=CONFIG.floorY+0.5; p.vy*=-0.6; p.vx*=F; p.vz*=F; if(Math.abs(p.vy)<0.1)p.state='FLOOR'; }
                } else if(p.state==='FLOOR') p.y=CONFIG.floorY+0.5;

                dummy.position.set(p.x, p.y, p.z);
                dummy.rotation.set(p.rx, p.rx, p.rx);
                dummy.updateMatrix();
                mesh.setMatrixAt(i, dummy.matrix);
                mesh.setColorAt(i, colorHelper.setHex(p.c));
            }
            mesh.instanceMatrix.needsUpdate = true;
            mesh.instanceColor.needsUpdate = true;
            renderer.render(scene, camera);
        }

        function onResize() {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>