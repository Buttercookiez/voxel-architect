<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voxel Architect | Raw AI Connection</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        :root { --bg: #e8ebee; --panel: rgba(255, 255, 255, 0.98); --text: #1a1a1a; --accent: #111; }
        body { margin: 0; overflow: hidden; background-color: var(--bg); font-family: 'Inter', sans-serif; color: var(--text); }
        #header { position: absolute; top: 40px; left: 40px; pointer-events: none; z-index: 10; }
        h1 { margin: 0; font-size: 28px; font-weight: 800; text-transform: uppercase; color: var(--accent); }
        p { margin: 4px 0 0; font-size: 14px; color: #666; font-weight: 500; }
        
        /* UI Controls */
        #ui-container { position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%); display: flex; align-items: center; gap: 12px; padding: 12px 16px; background: var(--panel); backdrop-filter: blur(20px); border-radius: 18px; box-shadow: 0 15px 50px rgba(0,0,0,0.1); z-index: 100; }
        input { border: none; background: rgba(0,0,0,0.05); padding: 14px 18px; border-radius: 10px; font-size: 16px; font-weight: 600; width: 220px; outline: none; }
        button { border: none; cursor: pointer; padding: 14px 24px; border-radius: 10px; font-size: 14px; font-weight: 700; text-transform: uppercase; display: flex; align-items: center; gap: 8px; }
        #btn-gen { background-color: var(--accent); color: white; }
        #btn-break { background-color: transparent; color: var(--text); border: 1px solid transparent; }
        .loader { width: 14px; height: 14px; border: 2px solid #fff; border-bottom-color: transparent; border-radius: 50%; display: none; animation: rotation 0.5s linear infinite; }
        @keyframes rotation { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Debug Screen Overlay */
        #error-console {
            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 80%; max-width: 600px; background: rgba(20, 0, 0, 0.95); border: 2px solid #ff4444;
            color: #ffaaaa; padding: 30px; border-radius: 16px; font-family: monospace; z-index: 999;
            box-shadow: 0 0 50px rgba(255, 0, 0, 0.2); white-space: pre-wrap; overflow-y: auto; max-height: 80vh;
        }
        #error-console h3 { color: #ff4444; margin-top: 0; text-transform: uppercase; }
        .close-btn { position: absolute; top: 10px; right: 10px; color: white; cursor: pointer; background: #333; padding: 5px 10px; border-radius: 4px; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

    <div id="header"><h1>Voxel Architect</h1><p>Raw Connection Mode</p></div>
    
    <!-- ERROR BOX -->
    <div id="error-console">
        <div class="close-btn" onclick="this.parentElement.style.display='none'">X</div>
        <h3>Google API Error</h3>
        <div id="error-text">Waiting...</div>
    </div>

    <div id="ui-container">
        <input type="text" id="input-text" value="Car" placeholder="Enter prompt..." spellcheck="false">
        <button id="btn-gen"><span>Generate</span><div class="loader" id="ai-loader"></div></button>
        <button id="btn-break">Shatter</button>
    </div>

    <script>
        const API_KEY = "AIzaSyD5Q3y40BPiwtSUzBTRoU2n2CgIiqWrYpE"; 
        const CONFIG = { bg: 0xe8ebee, floorY: -12, voxelSize: 1, gap: 0.02, maxParticles: 8000, animSpeed: 0.2 };
        let scene, camera, renderer, controls, mesh, particles = [], dummy = new THREE.Object3D(), colorHelper = new THREE.Color();

        function init() {
            scene = new THREE.Scene(); scene.background = new THREE.Color(CONFIG.bg); scene.fog = new THREE.Fog(CONFIG.bg, 30, 100);
            camera = new THREE.PerspectiveCamera(40, window.innerWidth/window.innerHeight, 0.1, 1000); camera.position.set(30, 25, 30);
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding; renderer.toneMapping = THREE.ACESFilmicToneMapping;
            document.body.appendChild(renderer.domElement);
            controls = new THREE.OrbitControls(camera, renderer.domElement); controls.autoRotate = true; controls.autoRotateSpeed = 2.0; controls.enableDamping = true;
            
            const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.65);
            const key = new THREE.DirectionalLight(0xfff0dd, 1.2); key.position.set(20,40,20); key.castShadow=true; key.shadow.mapSize.width=2048; key.shadow.mapSize.height=2048;
            scene.add(hemi); scene.add(key);
            const pg = new THREE.PlaneGeometry(200,200); const pm = new THREE.ShadowMaterial({opacity:0.15});
            const p = new THREE.Mesh(pg,pm); p.rotation.x=-Math.PI/2; p.position.y=CONFIG.floorY; p.receiveShadow=true; scene.add(p);
            
            const g = new THREE.BoxGeometry(0.98,0.98,0.98); const m = new THREE.MeshStandardMaterial({roughness:0.4, metalness:0.1});
            mesh = new THREE.InstancedMesh(g,m,CONFIG.maxParticles); mesh.castShadow=true; mesh.receiveShadow=true; scene.add(mesh);

            const inp = document.getElementById('input-text');
            inp.addEventListener('keydown',e=>e.stopPropagation());
            inp.addEventListener('keypress',e=>{if(e.key==='Enter') generateWithAI()});
            
            document.getElementById('btn-gen').onclick = generateWithAI;
            document.getElementById('btn-break').onclick = shatter;
            window.addEventListener('resize', ()=>{camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();renderer.setSize(window.innerWidth,window.innerHeight)});
            
            generateEmptyBox();
            animate();
        }

        function showError(msg, rawJson) {
            const el = document.getElementById('error-console');
            const txt = document.getElementById('error-text');
            el.style.display = 'block';
            txt.innerText = `${msg}\n\n--- GOOGLE RESPONSE ---\n${JSON.stringify(rawJson, null, 2)}`;
        }

        function generateEmptyBox() {
            let t = []; 
            for(let x=-3; x<3; x++) for(let y=0; y<3; y++) for(let z=-3; z<3; z++) t.push({x,y,z,c:0xcfd8dc});
            processTargets(t);
        }

        // --- REAL CONNECTION LOGIC ---
        async function generateWithAI() {
            const prompt = document.getElementById('input-text').value.trim();
            if(!prompt) return;

            const loader = document.getElementById('ai-loader');
            const btnSpan = document.querySelector('#btn-gen span');
            loader.style.display='block'; btnSpan.style.display='none';
            document.getElementById('error-console').style.display='none';

            try {
                // FORCE FLASH 1.5
                const modelName = "gemini-1.5-flash"; 
                const url = `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${API_KEY}`;
                
                const systemPrompt = `
                    Task: Generate a 3D Voxel Model of "${prompt}".
                    Format: Returns a JSON array: [{"x":0,"y":0,"z":0,"c":"#FF0000"}].
                    Strict Constraints: 
                    1. Do NOT build letters/text. Build the PHYSICAL object. 
                    2. Size between 10x10x10 and 16x16x16. 
                    3. Return ONLY valid raw JSON. No markdown.
                `;

                console.log("Connecting to:", url);

                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: systemPrompt }] }],
                        generationConfig: { temperature: 0.3, maxOutputTokens: 2500 },
                        safetySettings: [
                            { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
                            { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
                            { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
                            { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" }
                        ]
                    })
                });

                // If HTTP Error, extract body and Show User
                if (!response.ok) {
                    const errorBody = await response.json().catch(()=>({ error: "Could not parse error body" }));
                    showError(`HTTP Error: ${response.status} (${response.statusText})`, errorBody);
                    throw new Error("Stopped due to HTTP error");
                }

                const data = await response.json();
                
                // Check validity
                if (!data.candidates || !data.candidates[0].content) {
                    showError("Valid HTTP 200, but Empty Response. (Likely Safety Block)", data);
                    throw new Error("Empty Content");
                }

                let text = data.candidates[0].content.parts[0].text;
                
                // Clean JSON formatting
                text = text.replace(/```json/g, '').replace(/```/g, '').trim();
                const first = text.indexOf('[');
                const last = text.lastIndexOf(']');
                
                if(first === -1 || last === -1) {
                    showError("AI Replied, but did not return JSON array.", { raw_text: text });
                    throw new Error("Bad JSON");
                }

                text = text.substring(first, last+1);
                
                let voxelData;
                try {
                    voxelData = JSON.parse(text);
                } catch(e) {
                    showError("JSON Parsing Failed.", { error: e.message, raw_text: text });
                    throw new Error("JSON Parse Fail");
                }

                if(Array.isArray(voxelData) && voxelData.length > 0) {
                    const targets = voxelData.map(v => ({
                        x: v.x||0, y: v.y||0, z: v.z||0,
                        c: parseInt((v.c||"#888888").replace('#', '0x'), 16)
                    }));
                    processTargets(targets);
                } else {
                    showError("AI returned empty array.", { data: voxelData });
                }

            } catch(e) {
                console.error("Stopped:", e);
            } finally {
                loader.style.display='none'; btnSpan.style.display='block';
            }
        }

        // --- ANIMATION CORE ---
        function processTargets(t){
            let mx=0,my=0,mz=0; t.forEach(o=>{mx+=o.x;my+=o.y;mz+=o.z}); const cx=mx/t.length,cy=my/t.length,cz=mz/t.length;
            t.forEach(o=>{o.wx=(o.x-cx)*CONFIG.voxelSize;o.wy=(o.y-cy)*CONFIG.voxelSize+5;o.wz=(o.z-cz)*CONFIG.voxelSize});
            if(particles.length===0) for(let i=0;i<CONFIG.maxParticles;i++) particles.push({x:(Math.random()-.5)*20,y:CONFIG.floorY+.5,z:(Math.random()-.5)*20,rx:0,c:0xcfd8dc,state:'FLOOR',vx:0,vy:0,vz:0});
            particles.forEach((p,i)=>{if(i<t.length){p.target=t[i];p.state='FLYING';p.delay=(t[i].y*1)+Math.random()*5}else p.state='FLOOR'});
            controls.autoRotate=true;
        }
        function shatter(){controls.autoRotate=false;particles.forEach(p=>{if(p.state==='ASSEMBLED'||p.state==='FLYING'){p.state='FALLING';p.vx=(Math.random()-.5)*1.5;p.vy=Math.random()*1.5;p.vz=(Math.random()-.5)*1.5;p.vrx=(Math.random()-.5)*.5}})}
        function animate(){
            requestAnimationFrame(animate);controls.update();mesh.count=Math.min(particles.length,CONFIG.maxParticles);
            for(let i=0;i<mesh.count;i++){
                const p=particles[i];
                if(p.state==='FLYING'){
                    if(p.delay>0){p.delay--;if(p.y<CONFIG.floorY+2)p.rx+=0.2}
                    else{
                        const dx=p.target.wx-p.x, dy=p.target.wy-p.y, dz=p.target.wz-p.z;
                        p.x+=dx*CONFIG.animSpeed; p.y+=dy*CONFIG.animSpeed; p.z+=dz*CONFIG.animSpeed; p.rx*=0.7;
                        if(Math.abs(dx)+Math.abs(dy)+Math.abs(dz)<0.1){p.state='ASSEMBLED';p.x=p.target.wx;p.y=p.target.wy;p.z=p.target.wz;p.c=p.target.c;p.rx=0}else p.c=p.target.c
                    }
                } else if(p.state==='ASSEMBLED'){p.x=p.target.wx;p.y=p.target.wy;p.z=p.target.wz}
                else if(p.state==='FALLING'){p.vy+=-0.05;p.x+=p.vx;p.y+=p.vy;p.z+=p.vz;p.rx+=p.vrx;if(p.y<CONFIG.floorY+0.5){p.y=CONFIG.floorY+0.5;p.vy*=-0.6;p.vx*=0.95;p.vz*=0.95;if(Math.abs(p.vy)<0.1)p.state='FLOOR'}}
                else if(p.state==='FLOOR')p.y=CONFIG.floorY+0.5;
                dummy.position.set(p.x,p.y,p.z);dummy.rotation.set(p.rx,p.rx,p.rx);dummy.updateMatrix();mesh.setMatrixAt(i,dummy.matrix);mesh.setColorAt(i,colorHelper.setHex(p.c));
            }
            mesh.instanceMatrix.needsUpdate=true;mesh.instanceColor.needsUpdate=true;renderer.render(scene,camera);
        }
        init();
    </script>
</body>
</html>